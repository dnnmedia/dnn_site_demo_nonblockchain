
import Text from './text';
import Node from './node';
import voidElements from 'void-elements';
import flatten from 'array-flatten';

const voidTags = new Set(voidElements);

export default class Element extends Node {

  constructor(tagName, isVoid){
    this.name = tagName;
    this.props = new Map;
    this.children = [];
    if (null != isVoid) {
      this.void = isVoid;
    } else {
      this.void = voidTags.has(tagName);
    }
  }

  add(...children){
    flatten(children)
    .filter(v =>  null != v && 'boolean' != typeof v)
    .map(v => {
      if ('string' == typeof v || 'number' == typeof v) {
        return new Text(String(v));
      } else {
        return v;
      }
    })
    .forEach(v => {
      this.children.push(v);
    });
    return this;
  }

  empty(){
    this.children = [];
    return this;
  }

  remove(child){
    this.children = this.children.filter(v => {
      return v == child;
    });
    return this;
  }

  set(prop, value){
    if ('object' == typeof prop) {
      for (let key in prop) {
        this.set(key, prop[key]);
      }
    } else {
      if ('text' == prop) {
        this.add(null == value ? '' : value);
      } else {
        this.props.set(prop, value);
      }
    }
    return this;
  }

  toHTML(){
    let tag = this.name.toLowerCase();
    let html = `<${tag}`;

    // attributes
    this.props.forEach((val, key) => {
      html += ` ${key}=${JSON.stringify(val)}`;
    });

    html += '>';

    // children
    let contentLength = 0;
    this.children.forEach(el => {
      let add = el.toHTML();
      contentLength += add.length;
      html += add;
    });

    // closing
    if (contentLength || !this.void) {
      html += `</${tag}>`;
    }

    return html;
  }

}
