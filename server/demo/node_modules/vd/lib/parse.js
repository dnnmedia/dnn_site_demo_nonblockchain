
// parses:
// <a href="#">
// a href="#" title=woot
// div.main
// div.left.red
// div.left.red class=woot
// .left.red

export default function parse(str){
  let pieces = str
  .replace(/^</, '')
  .replace(/>$/, '')
  .split(/\s+/);

  let { tag, classes } = parseTag(pieces.shift());
  let attrs = parseAttrs(pieces.join(' '));

  // merge classes
  if (classes.length || null != attrs.class) {
    attrs.class = classes.join(' ')
      + (null == attrs.class ? '' : attrs.class);
  }

  return { tag: tag, attrs: attrs };
}

function parseTag(str){
  let ret = {};
  let tag = str.match(/^[^\.]+/);
  let classes = str.match(/\.([^\.]+)/g);

  // defaults
  tag = tag ? tag[0] : 'div';
  classes = classes || [];

  // remove leading `.`
  classes = classes.map(function(v){
    return v.substr(1);
  });

  return { tag: tag, classes: classes };
}

function parseAttrs(str){
  let attrs = {};
  let key, val, stop;

  for (let i = 0; i < str.length; i++) {
    let chr = str[i];

    if (null == val) {
      // accumulating key
      if (null == key) key = '';
      if ('=' == chr) {
        val = '';
      } else if (/\s/.test(chr)) {
        if (key.length) {
          attrs[key] = true;
          key = null;
        }
      } else {
        key += chr;
      }
    } else {
      // accumulating value
      let stopped;

      if (!stop) {
        if (/['"]/.test(chr)) {
          stop = new RegExp(chr);
        } else {
          stop = /\s/;
          val += chr;
        }
      } else {
        stopped = stop.test(chr);
        if (!stopped) val += chr;
      }

      if (stopped || (i + 1 == str.length)) {
        attrs[key] = val;
        key = val = stop = null;
      }
    }
  }

  // use `true` for missing values
  if (null != key) attrs[key] = true;

  return attrs;
}
